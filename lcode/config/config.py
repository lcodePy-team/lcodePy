import numpy as np
import re
import lcode

from copy import copy
from typing import Any

from .template import lcode_template
from .default_config_values import default_config_values


class Config:
    # We don't really need config_values, can work with _arr. TODO: discuss this.
    # config_values: dict[str, str] # And we don't really need to declare this.

    def __init__(self, new_config_values: dict=None, default_config=True):
        # Initialize an empty dictionaty for config values:
        self.config_values = {}

        # This value stores information about whether we use numpy or cupy in
        # our code. Bu now, it is used only by 3d parts of lcodePy.
        self.xp = np

        # If a user wants to set config_values over default ones, then he/she
        # just writes: config = Config() /If a user wants to create a new empty
        # config, then he/she writes: config = Config(default_config=False)
        if default_config:
            self.update(default_config_values)

        # If a user sets new config values when initializing a new config:
        if new_config_values is not None:
            self.update(new_config_values)

    def get(self, option_name: str, fallback: str = '') -> str:
        if option_name in self.config_values:
            return str(self.config_values.get(option_name))
        else:
            return fallback

    def getraw(self, option_name):
        return self.config_values.get(option_name)


    def getbool(self, option_name: str, fallback: bool = 0) -> bool:
        str_value = self.get(option_name).lower()
        if str_value == 'true':
            return True
        elif str_value == 'false':
            return False
        else:
            return fallback

    def getint(self, option_name: str, fallback: int = 0) -> int:
        try:
            return int(float(self.get(option_name)))
        except ValueError:
            return fallback

    def getfloat(self, option_name: str, fallback: float = 0.0) -> float:
        try:
            return float(self.get(option_name))
        except ValueError:
            return fallback

    def set(self, option_name: str, option_value: Any):
        self.config_values[option_name] = option_value

        # We intercept the setting of a new configuration value
        # in order to adjust other values:
        self.adjust_config_values_on_set(option_name)

    def update(self, new_config_values: dict=None): #, **kconfig_values):
        """
        Works similarly to the update() method of a Python dictionary:
        this method inserts the specified items to the config_values.
        """
        if new_config_values is not None:
            for key in new_config_values:
                self.set(key, new_config_values[key])

        # We can add this part if we want to support **karg
        # for key in kconfig_values:
        #     self.set(key, kconfig_values[key])

    def dump(self, runas_name):
        str_keys = set(['processing-unit-type',
                        'geometry',
                        'ion-model',
                        'plasma-shape',
                        'plasma-zshape', 
                        'plasma-rshape',
                        ])
        if 'extra' in runas_name:
            n_lines = -1
        else:
            n_lines = 94
        path_to_default = '/'.join(__file__.split('/')[:-1]) \
                          + "/default_config_values.py"
        conf_file = open(path_to_default,'r').readlines()
        conf_file = ''.join(conf_file[3:n_lines]) + '}'
        conf_file = '"""\n' \
            + 'Simulation preformed with following lcode settings.\n' \
            + f'Generated by lcode version {lcode.__version__}.\n' \
            + f'Fill free to contact team@lcode.info for assistance.\n' \
            + '"""\n\n' \
            + 'config = {\n' \
            + conf_file
        for key, value in self.config_values.items():
            old_line = fr"'{key}': .*?(?=,)"
            if key in str_keys:
                if key == "plasma-zshape": 
                    profile = [8 * " " + x.strip() for x in 
                               value.lower().strip().split('\n')]
                    profile = r"\n".join(profile) + r"\n" + 8 * r" " + r"'''"
                    new_line = fr"'{key}': '''\n{profile}"
                    old_line = fr"'{key}': '''\n        '''"
                    
                elif key == "plasma-rshape":
                    if isinstance(value, int):
                        new_line = fr"'{key}': {value}"
                        continue
                    elif len(value.split()) == 1:
                        new_line = fr"'{key}': '{value.lower()}'"
                        continue
                    profile = [8 * " " + x.strip() for x in 
                               value.lower().strip().split('\n')]
                    profile = r"\n".join(profile) + r"\n" + 8 * r" " + r"'''"
                    new_line = fr"'{key}': '''\n{profile}"
                    
                elif key == 'plasma-shape' and callable(value):
                    new_line = fr"'{key}': 'external function {value}'"
                    
                else: 
                    new_line = fr"'{key}': '{value.lower()}'"
            else:
                new_line = fr"'{key}': {value}"
            conf_file = re.sub(old_line, new_line, conf_file)
        if self.config_values['geometry'].lower() == '3d': 
            key = 'window-width'
            value = float(self.config_values['window-width']) / 2
            old_line = fr"'{key}': .*?(?=,)"
            new_line = fr"'{key}': {value}"
            conf_file = re.sub(old_line, new_line, conf_file)
        
        with open(runas_name, 'w') as f_out:
            f_out.write(conf_file)
        

    def __copy__(self) -> 'Config':
        """
        Works similarly to the copy() method of a Python dictionary.
        """
        ret = Config()
        ret.config_values = copy(self.config_values)
        return ret

    def c_config(self, path:str = None) -> str:
        cfg = lcode_template.format(**self.config_values)
        if path:
            with open(path, 'w') as cfg_f:
                cfg_f.write(cfg)
        return cfg

    def adjust_config_values_on_set(self, option_name: str):
        """
        Adjusts config values when we use config.set(...).
        """
        if option_name == 'processing-unit-type':
            # Goes here every time Config['processing-unit-type'] = 'cpu'/'gpu'
            # or something similar is called to change the type of the main
            # array manipulating library.
            pu_type = self.get('processing-unit-type').lower()
            if pu_type == 'cpu':
                self.xp = np
            elif pu_type == 'gpu':
                import cupy as cp
                self.xp = cp

        if (option_name == 'geometry' and \
            self.config_values['geometry'] == "circ"):
            # 2d and circ are now the same.
            self.config_values['geometry'] = '2d'

    def _adjust_config_values_3d(self):
        """
        Adjust some parameters for 3d simulation to fit 2D case.
        Tweak some parameters to improve stability and performance 
        """
        if self.get('geometry')  == '3d':
            self.set('window-width', 2 * self.getfloat('window-width'))
            self.adjust_window_width_and_steps_3d()
            self.adjust_plasma_fineness()
            if self.get('field-solver-subtraction-coefficient') == '1':
                self.set('field-solver-subtraction-coefficient', 
                         1 + self.getfloat('xi-step'))

    def adjust_window_width_and_steps_3d(self):
        """
        Calculates the optimal number for window-width-steps and uses
        it to adjust window-width and window-width-steps in case of 3d.
        """
        # 0. Calculates an estimation of 'window-width-steps' value.
        estim = int(self.getfloat('window-width') /
                    self.getfloat('transverse-step'))

        # 1. Calculates good numbers around the estimation.
        #    Hopefully, the difference is less than 100.
        # TODO: Rewrite so that there are no exceptions.
        lower_bound = (estim - 100) if (estim - 100) > 0 else 0
        good_numbers = np.array([a for a in range(lower_bound, estim + 100)
                                 if good_size(a)])

        # 2. Finds the closest good number to the estimation and
        #    uses it to adjust window-width and window-width-steps.
        optimal_steps = good_numbers[np.abs(good_numbers - estim).argmin()]
        self.set('window-width', (optimal_steps *
                                  self.getfloat('transverse-step')))
        self.set('window-width-steps', optimal_steps)
        # TODO: Add a message for the user.

    def adjust_plasma_fineness(self):
        """
        Calculates and adjusts 'plasma-fineness' using
        'plasma-particles-per-cell'.
        """
        sqrt_per_cell = np.sqrt(self.getfloat('plasma-particles-per-cell'))
        self.set('plasma-fineness', round(sqrt_per_cell))
        self.set('plasma-particles-per-cell', round(sqrt_per_cell) ** 2)

        if 0. < sqrt_per_cell and sqrt_per_cell < 1.:
            self.set('plasma-fineness', 1 / round(1 / sqrt_per_cell))
            self.set('plasma-particles-per-cell',
                     1 / round(1 / sqrt_per_cell) ** 2)

        # TODO: Add a message for the user.


def factorize(number, factors = []):
    """
    Finds all factors of a number.
    """
    if number <= 1:
        return factors
    for i in range(2, number + 1):
        if number % i == 0:
            return factorize(number // i, factors + [i])


def good_size(number):
    """
    Checks if a number is a good number. For more information
    on what good numbers are:
    http://www.fftw.org/doc/Real_002dto_002dReal-Transforms.html
    """
    factors = factorize(number - 1)
    return (all([f in [2, 3, 4, 5, 7, 11, 13] for f in factors]) and
            factors.count(11) + factors.count(13) < 2 and number % 2)

def find(cfg, par):
    ans = re.search('\s' + par + '\s?=\s?[-+]?(\d+(\.\d*)?|\.\d+)([eE][-+]?\d+)?', cfg)
    return float(ans.group(0).replace(par,'').replace('=', ''))

def find_char(cfg, par):
    ans = re.search(par + '\s?=\s?[a-zA-Z][a-zA-Z]*', cfg)
    return ans.group(0).replace(par,'').replace('=', '').replace(' ','')

def find_beam_profile(cfg):
    ans = re.search('beam-profile\s?=\s?"""([^\>]*)"""', cfg)
    return ans.group(1)